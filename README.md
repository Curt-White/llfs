# LLFS (Journaled File System)

## Files & Inodes

The implementation defined here follows the specifications very closely ensuring that each of
the requirements are properly implemented. The system uses the free blocks map as described in
class using bitwise operators to set and unset the bits. The inodes are also defined the same except
that instead of using an integer for the flags portion of the inode I used a bit field. This allows
us to define custom length fields that we can access like a struct instead of using bitwise ops
to set flag values. There is also an inode map at the beginning of the file system directly after
the free block map which holds the block number of the inode. This file system has a maximum of 256
inodes since the directory entry description in the document only allows one byte for the inode number.
The inode map is 2 blocks since this part of the system was originally designed for more inodes as it is
constructed from 4 byte integers.

The reads for reserving blocks and inodes are still very fast since they are cached in memory at all
time. However, there is an overhead to keeping them updated. Every time we make a modification to the
inode maps when writing new blocks the maps are written with the blocks. This means that the maps
are getting written to the blocks fairly often and may become slow when writing huge files to the
disk constantly. It is unnoticeable with LLFS.

Inode take up only 32 bytes but they will take up an entire block. All constructs consume an entire block
even if they do not use that entire block. Indirect mapping blocks take up a whole block though there
may only be one indirect block.

Blocks 0 - 11 are reserved for future use or are in use by maps. Many of these spaces
are given so that the Inode map has room to expand if system is configured this way. This
would require that dir entry size be changed however. The journal starts on block 12 and
continues through to block 31.

## Indirect Blocks

This file system employs indirect and double indirect blocks. Once the file grows beyond 10 blocks
the files grows into the indirect blocks. The file system handles all of the abstractions with these
blocks though the code has become quite complicated as a result.


## The Journal & Adding Robustness

In order to add robustness to the file system it uses a journal. Every time the file system makes an update
to the files, it first records the blocks it is going to write in the journal. The process goes as follows:

1) Some process or function call performs an action on the file system
2) All of the modified blocks are recorded to the block write buffer
3) After the block updates are done in memory the buffer is sent to the journal
4) The journal creates a new transaction at the location pointed to by the journal super block
5) A transaction header is created with the number of blocks and their final locations
6) All blocks are written to the journal
7) A commit block is written to the journal
8) After they are committed to the journal they are copied to their final locations
9) super block is updated to the next position after the commit & super block is updated to reflect new log start

The journal is circular and wraps around. It is is only 20 blocks in size so it can fill up fast so transactions
are limited to 10 blocks in length. Since there is no asynchronous disk to copy the blocks to their final
locations it is done synchronously with a call to commit transaction.

There are many trade-offs to this type of journal. The fact that all data is being written twice is slow
but it ensure the data's protection. There are many other types of journals where we can use methods such
as ordered writing but these do not provide the same level of safety.

## Notes

* There are extensive tests inside the unit directory which is currently stored in the /apps directory. 

* Each of the unit tests makes its own disk with a different name since it is difficult 
todo unit tests when there are unexpected changes made to the same disk. The test01.c and test02.c
use the vdisk file. 

* Even though all of the tests use InitLLFS at the start
of the test for unit testing purposes, it is also possible to use llfs_load
which brings all of the data from the disk such as block map and inode map into memory.

* Also, in the journal file there are a couple unimplemented functions. This is simply because
I originally had more plans for checksums and stuff but ran out of time. I left them there simply because I might finish them in the future.

* The file_disk generated by the test_file.c program generates a good
example of nested documents, reading and writing to nested files, reading and
writing to files in root and generates large files using single and double
indirect blocks

* A disk must be mounted first using the disk_mount function

* Also when looking at the block map for each byte they reserve blocks
from right to left. So the bytes are still traversed from left to right
but the bits inside the block are reserved from right to left.
